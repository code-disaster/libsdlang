/*******************************************************************************
 * This .c file is generated by Ragel. Do not edit!
 *   $ ragel -L -G2 -o sdlang.c sdlang.rl
 ******************************************************************************/

#include "sdlang.h"

#include <stdio.h>

%%{

    machine sdlang;

    prepush {
        check_stack_size(top, curline);
    }

    newline = '\r'? '\n' @{curline += 1;};
    newline_wrap = '\\' newline;
    any_count_line = any | newline;

# +> tick vs backtick

    single_quote_char = [^'`\\] | newline | ( '\\' . any_count_line );
    single_quote_string = ['`]{1} . single_quote_char* . ['`]{1};

    double_quote_char = [^"\\] | newline | ( '\\' any_count_line );
    double_quote_string = '"' . double_quote_char* . '"';

    any_string = single_quote_string | double_quote_string;

    kw_true = 'true' | 'on';
    kw_false = 'false' | 'off';
    kw_null = 'null';
    keywords = kw_true | kw_false | kw_null;

    alnum_literal = alnum | [\.\:\-_$];
    literal = alpha . alnum_literal* - keywords;

    cpp_comment = '//' [^\n]* newline;
    lua_comment = '--' [^\n]* newline;
    bash_comment = '#' [^\n]* newline;
    one_line_comment = cpp_comment | lua_comment | bash_comment;

    c_comment := any_count_line* :>> '*/' @{fgoto block;};

# +> +/-
# +> exponent format

    float_fract = digit* '.' digit+ | digit+ '.';
    float_exp = [eE] [+\-]? digit+;

    float64 = [+\-]? (float_fract float_exp? | digit+ float_exp);
    float32 = float64 [fF];

    int32 = [+\-]? ('0' | [1-9] [0-9]*);
    int64 = int32 [lL];

    attribute = literal '=';

    block := |*

        attribute {emit(SDLANG_TOKEN_ATTRIBUTE, ts, te, curline);};

        literal {emit(SDLANG_TOKEN_NODE, ts, te, curline);};

        any_string {emit(SDLANG_TOKEN_STRING, ts, te, curline);};

        float32 {emit(SDLANG_TOKEN_FLOAT32, ts, te, curline);};
        float64 {emit(SDLANG_TOKEN_FLOAT64, ts, te, curline);};

        int64 {emit(SDLANG_TOKEN_INT64, ts, te, curline);};
        int32 {emit(SDLANG_TOKEN_INT32, ts, te, curline);};

        kw_true {emit(SDLANG_TOKEN_TRUE, ts, te, curline);};
        kw_false {emit(SDLANG_TOKEN_FALSE, ts, te, curline);};

        kw_null {emit(SDLANG_TOKEN_NULL, ts, te, curline);};

# 128-bit ints
# data/time formats
# base64 data
# skip empty lines
# lazy token_end

        ';' {emit(SDLANG_TOKEN_NODE_END, ts, te, curline);};

        '{' {
            emit(SDLANG_TOKEN_BLOCK, ts, te, curline);
            fcall block;
        };

        '}' {
            emit(SDLANG_TOKEN_BLOCK_END, ts, te, curline);
            fret;
        };

        one_line_comment;
        '/*' {fgoto c_comment;};

        newline_wrap; # wrapping newlines do not end node
        newline {emit(SDLANG_TOKEN_NODE_END, NULL, NULL, curline);};

        [ \t];

    *|;

    main := |*
        # Just enter the top-level block.
        any {fhold; fcall block;};
    *|;

}%%

%% write data nofinal;

static void emit_token(const struct sdlang_token_t* token)
{
    fprintf(stdout, "[%2d] type=%d, value=", token->line, token->type);
    if (token->string.from < token->string.to)
    {
        fwrite(token->string.from, 1, token->string.to - token->string.from, stdout);
    }
    else
    {
        fprintf(stdout, "n/a");
    }
    fprintf(stdout, "\n");
}

void (*sdlang_emit_token)(const struct sdlang_token_t* token) = emit_token;

static void emit(enum sdlang_token_type_t type, const char* ts, const char* te, int line)
{
    switch (type)
    {
    case SDLANG_TOKEN_ATTRIBUTE:
        /* strip trailing '=' */
        --te;
        break;

    case SDLANG_TOKEN_INT32:
    case SDLANG_TOKEN_INT64:
    case SDLANG_TOKEN_FLOAT32:
    case SDLANG_TOKEN_FLOAT64:
        /* strip leading '+' */
        if (*ts == '+')
        {
            ++ts;
        }
        break;

    case SDLANG_TOKEN_STRING:
        /* strip quotes */
        ++ts;
        --te;
        break;

    default:
        break;
    }

    const struct sdlang_token_t token = {
        .type = type,
        .string = {
            .from = ts,
            .to = te
        },
        .line = line
    };

    (*sdlang_emit_token)(&token);
}

static void report_error(enum sdlang_error_t error, int line)
{
    switch (error)
    {
    case SDLANG_ERROR_PARSE_ERROR:
        fprintf(stderr, "parse error at line %d\n", line);
        break;
    case SDLANG_ERROR_OUT_OF_BUFFER:
        fprintf(stderr, "out of buffer memory at line %d\n", line);
        break;
    case SDLANG_ERROR_STACK_FULL:
        fprintf(stderr, "parser stack full at line %d, crash imminent\n", line);
        break;
    default:
        fprintf(stderr, "unknown error [%d] at line %d\n", error, line);
        break;
    }
}

void (*sdlang_report_error)(enum sdlang_error_t error, int line) = report_error;

static void check_stack_size(int top, int line)
{
    if (top == SDLANG_PARSE_STACKSIZE)
    {
        SDLANG_ASSERT(0 && " stack overflow");
    }
    else if (top == SDLANG_PARSE_STACKSIZE - 1)
    {
        (*sdlang_report_error)(SDLANG_ERROR_STACK_FULL, line);
    }
}

int sdlang_parse(size_t (*stream)(void* ptr, size_t size, size_t nmemb))
{
    char buf[SDLANG_PARSE_BUFFERSIZE];
    int cs, act, have = 0, curline = 1;
    int stack[SDLANG_PARSE_STACKSIZE], top = 0;
    char *ts, *te = 0;
    int done = 0;

    %% write init;

    while (!done)
    {
        char *p = buf + have, *pe, *eof = 0;
        int len, space = SDLANG_PARSE_BUFFERSIZE - have;

        if (space == 0)
        {
            (*sdlang_report_error)(SDLANG_ERROR_OUT_OF_BUFFER, curline);
            break;
        }

        len = stream(p, 1, space);
        pe = p + len;

        if (len < space)
        {
            eof = pe;
            done = 1;
        }

        %% write exec;

        if (cs == sdlang_error)
        {
            (*sdlang_report_error)(SDLANG_ERROR_PARSE_ERROR, curline);
            break;
        }

        if (ts == 0)
        {
            have = 0;
        }
        else
        {
            have = pe - ts;
            SDLANG_MEMMOVE(buf, ts, have);
            te = buf + (te - ts);
            ts = buf;
        }
    }

    return done ? 0 : 1;
}
